<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ªç©ºæˆ˜æœº - HTML5é£æœºå¤§æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            overflow: hidden;
            padding: 20px;
        }
        
        .game-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 10px #00b7ff, 0 0 20px #00b7ff;
            color: #fff;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
        }
        
        canvas {
            background: linear-gradient(180deg, #0a0a2a, #1c1c3a);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 183, 255, 0.5);
            display: block;
            margin: 0 auto;
            border: 2px solid #00b7ff;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin-bottom: 15px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 183, 255, 0.3);
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #00b7ff;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
            color: #00b7ff;
            font-size: 1rem;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            display: none;
            z-index: 100;
            border: 2px solid #ff073a;
        }
        
        .game-over h2 {
            font-size: 2.5rem;
            color: #ff073a;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff073a;
        }
        
        .final-score {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: #fff;
        }
        
        .restart-btn {
            padding: 12px 25px;
            background: linear-gradient(135deg, #ff073a, #ff4d00);
            border: none;
            border-radius: 50px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 7, 58, 0.5);
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 7, 58, 0.7);
        }
        
        .instructions {
            max-width: 800px;
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            text-align: center;
        }
        
        .instructions h3 {
            color: #00b7ff;
            margin-bottom: 15px;
        }
        
        .instructions p {
            margin: 8px 0;
            color: #ccc;
        }
    </style>
</head>
<body>
    <h1 class="game-title">å¤ªç©ºæˆ˜æœº</h1>
    
    <div class="game-stats">
        <div class="stat">
            <div class="stat-label">åˆ†æ•°</div>
            <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat">
            <div class="stat-label">ç”Ÿå‘½å€¼</div>
            <div class="stat-value" id="lives">3</div>
        </div>
        <div class="stat">
            <div class="stat-label">ç­‰çº§</div>
            <div class="stat-value" id="level">1</div>
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        
        <div class="game-over" id="gameOver">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <div class="final-score">æœ€ç»ˆå¾—åˆ†: <span id="finalScore">0</span></div>
            <button class="restart-btn" id="restartBtn">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    
    <div class="controls">
        <p>æ§åˆ¶: â† â†’ ç§»åŠ¨é£èˆ¹ | ç©ºæ ¼é”®å°„å‡»</p>
        <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: center;">
            <button id="audioToggle" style="padding: 8px 15px; background: linear-gradient(135deg, #3498db, #2980b9); border: none; border-radius: 20px; color: white; cursor: pointer;">ğŸ”Š éŸ³æ•ˆå¼€å¯</button>
            <button id="bgmToggle" style="padding: 8px 15px; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 20px; color: white; cursor: pointer;">ğŸµ BGMå¼€å¯</button>
        </div>
    </div>
    
    <div class="instructions">
        <h3>æ¸¸æˆè¯´æ˜</h3>
        <p>å‡»è½æ•Œæœºè·å¾—åˆ†æ•°ï¼Œæ¯1000åˆ†å‡ä¸€çº§</p>
        <p>çº¢è‰²æ•Œæœº: 10åˆ† | ç»¿è‰²æ•Œæœº: 20åˆ† | è“è‰²æ•Œæœº: 50åˆ†</p>
        <p>é¿å…ä¸æ•Œæœºç›¸æ’ï¼Œä½ æœ‰3æ¡ç”Ÿå‘½</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // è·å–Canvaså’ŒContext
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // æ¸¸æˆçŠ¶æ€å…ƒç´ 
            const scoreElement = document.getElementById('score');
            const livesElement = document.getElementById('lives');
            const levelElement = document.getElementById('level');
            const gameOverElement = document.getElementById('gameOver');
            const finalScoreElement = document.getElementById('finalScore');
            const restartBtn = document.getElementById('restartBtn');
            
            // æ¸¸æˆå˜é‡
            let score = 0;
            let lives = 3;
            let level = 1;
            let gameOver = false;
            let animationId;
            
            // ç©å®¶é£æœº
            const player = {
                x: canvas.width / 2 - 25,
                y: canvas.height - 70,
                width: 50,
                height: 60,
                speed: 4, // é™ä½åŸºç¡€é€Ÿåº¦
                maxSpeed: 6, // æœ€å¤§é€Ÿåº¦
                acceleration: 0.3, // åŠ é€Ÿåº¦
                deceleration: 0.2, // å‡é€Ÿåº¦
                velocity: 0, // å½“å‰é€Ÿåº¦
                color: '#00b7ff',
                bullets: [],
                lastShot: 0,
                shootDelay: 300,
                invulnerable: false,
                invulnerableTime: 0,
                invulnerableDuration: 2000, // 2ç§’æ— æ•Œæ—¶é—´
                flashTime: 0
            };
            
            // æ•Œæœºæ•°ç»„
            let enemies = [];
            
            // çˆ†ç‚¸ç‰¹æ•ˆæ•°ç»„
            let explosions = [];
            
            // é“å…·ç³»ç»Ÿ
            let powerups = [];
            let playerPowerups = {
                fireRate: 1, // å°„é€Ÿå€æ•°
                multiBullet: 1, // å­å¼¹æ•°é‡
                wingman: false, // æ˜¯å¦æœ‰è¾…æœº
                wingmanHealth: 0 // è¾…æœºç”Ÿå‘½å€¼
            };
            
            // Bossç³»ç»Ÿ
            let boss = null;
            let bossActive = false;
            let bossSpawnScore = 5000; // Bosså‡ºç°åˆ†æ•°é—´éš”
            let lastBossScore = 0;
            
            // éŸ³é¢‘ç³»ç»Ÿ
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let audioEnabled = true;
            let bgmEnabled = true;
            let bgmPlaying = false;
            
            // éŸ³æ•ˆç”Ÿæˆå‡½æ•°
            function playSound(frequency, duration, type = 'sine', volume = 0.1) {
                if (!audioEnabled) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not available:', e);
                }
            }
            
            // èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ
            let bgmOscillators = [];
            let bgmGainNode;
            
            function startBGM() {
                if (!bgmEnabled || bgmPlaying) return;
                
                try {
                    bgmGainNode = audioContext.createGain();
                    bgmGainNode.connect(audioContext.destination);
                    bgmGainNode.gain.setValueAtTime(0.02, audioContext.currentTime); // å¾ˆä½çš„éŸ³é‡
                    
                    // æ›´ä¸°å¯Œçš„å¤ªç©ºä¸»é¢˜èƒŒæ™¯éŸ³ä¹
                    const melodies = [
                        [440, 523, 659, 523, 440, 349, 392, 440], // A-C-E-C-A-F-G-A
                        [523, 659, 784, 659, 523, 440, 392, 349], // C-E-G-E-C-A-G-F
                        [349, 392, 440, 523, 659, 523, 440, 392]  // F-G-A-C-E-C-A-G
                    ];
                    
                    const bassPatterns = [
                        [220, 220, 196, 196, 220, 220, 196, 196], // åŸºç¡€ä½éŸ³
                        [196, 196, 174, 174, 196, 196, 174, 174], // å˜åŒ–ä½éŸ³
                        [220, 196, 174, 196, 220, 196, 174, 196]  // å¤æ‚ä½éŸ³
                    ];
                    
                    const harmonyPatterns = [
                        [330, 392, 494, 392, 330, 262, 294, 330], // åŸºç¡€å’Œå£°
                        [392, 494, 587, 494, 392, 330, 294, 262], // é«˜å’Œå£°
                        [262, 294, 330, 392, 494, 392, 330, 294]  // ä½å’Œå£°
                    ];
                    
                    let patternIndex = 0;
                    let noteIndex = 0;
                    let beatCount = 0;
                    
                    function playBGMNote() {
                        if (!bgmPlaying) return;
                        
                        const currentTime = audioContext.currentTime;
                        const noteDuration = 0.6;
                        const currentMelody = melodies[patternIndex];
                        const currentBass = bassPatterns[patternIndex];
                        const currentHarmony = harmonyPatterns[patternIndex];
                        
                        // ä¸»æ—‹å¾‹ - å¸¦é¢¤éŸ³æ•ˆæœ
                        const melodyOsc = audioContext.createOscillator();
                        melodyOsc.type = 'sine';
                        melodyOsc.frequency.setValueAtTime(currentMelody[noteIndex], currentTime);
                        
                        // æ·»åŠ é¢¤éŸ³
                        const melodyLFO = audioContext.createOscillator();
                        const melodyLFOGain = audioContext.createGain();
                        melodyLFO.frequency.setValueAtTime(5, currentTime);
                        melodyLFOGain.gain.setValueAtTime(3, currentTime);
                        melodyLFO.connect(melodyLFOGain);
                        melodyLFOGain.connect(melodyOsc.frequency);
                        
                        melodyOsc.connect(bgmGainNode);
                        melodyOsc.start(currentTime);
                        melodyOsc.stop(currentTime + noteDuration);
                        melodyLFO.start(currentTime);
                        melodyLFO.stop(currentTime + noteDuration);
                        
                        // ä½éŸ³ - å¸¦åŒ…ç»œ
                        const bassOsc = audioContext.createOscillator();
                        bassOsc.type = 'triangle';
                        bassOsc.frequency.setValueAtTime(currentBass[noteIndex], currentTime);
                        
                        const bassGain = audioContext.createGain();
                        bassGain.gain.setValueAtTime(0.3, currentTime);
                        bassGain.gain.exponentialRampToValueAtTime(0.1, currentTime + noteDuration);
                        bassOsc.connect(bassGain);
                        bassGain.connect(bgmGainNode);
                        bassOsc.start(currentTime);
                        bassOsc.stop(currentTime + noteDuration);
                        
                        // å’Œå£° - å¸¦å»¶è¿Ÿæ•ˆæœ
                        const harmonyOsc = audioContext.createOscillator();
                        harmonyOsc.type = 'sawtooth';
                        harmonyOsc.frequency.setValueAtTime(currentHarmony[noteIndex], currentTime);
                        
                        const harmonyGain = audioContext.createGain();
                        harmonyGain.gain.setValueAtTime(0.2, currentTime);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.05, currentTime + noteDuration);
                        harmonyOsc.connect(harmonyGain);
                        harmonyGain.connect(bgmGainNode);
                        harmonyOsc.start(currentTime);
                        harmonyOsc.stop(currentTime + noteDuration);
                        
                        // æ·»åŠ é¼“ç‚¹æ•ˆæœï¼ˆæ¯4æ‹ï¼‰
                        if (beatCount % 4 === 0) {
                            const drumOsc = audioContext.createOscillator();
                            drumOsc.type = 'square';
                            drumOsc.frequency.setValueAtTime(80, currentTime);
                            
                            const drumGain = audioContext.createGain();
                            drumGain.gain.setValueAtTime(0.1, currentTime);
                            drumGain.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.1);
                            drumOsc.connect(drumGain);
                            drumGain.connect(bgmGainNode);
                            drumOsc.start(currentTime);
                            drumOsc.stop(currentTime + 0.1);
                        }
                        
                        noteIndex = (noteIndex + 1) % currentMelody.length;
                        beatCount++;
                        
                        // æ¯32æ‹åˆ‡æ¢æ¨¡å¼
                        if (beatCount % 32 === 0) {
                            patternIndex = (patternIndex + 1) % melodies.length;
                        }
                        
                        setTimeout(playBGMNote, noteDuration * 1000);
                    }
                    
                    bgmPlaying = true;
                    playBGMNote();
                } catch (e) {
                    console.log('BGM not available:', e);
                }
            }
            
            function stopBGM() {
                bgmPlaying = false;
                if (bgmGainNode) {
                    bgmGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                }
            }
            
            // é¢„å®šä¹‰éŸ³æ•ˆ
            const sounds = {
                shoot: () => playSound(400, 0.05, 'sine', 0.02),
                explosion: () => {
                    // çˆ†ç‚¸éŸ³æ•ˆ - ä½é¢‘å™ªéŸ³
                    playSound(100, 0.3, 'sawtooth', 0.1);
                    setTimeout(() => playSound(150, 0.2, 'triangle', 0.08), 50);
                },
                hit: () => playSound(200, 0.2, 'sine', 0.08),
                levelUp: () => {
                    // å‡çº§éŸ³æ•ˆ - ä¸Šå‡éŸ³é˜¶
                    playSound(440, 0.1, 'sine', 0.06);
                    setTimeout(() => playSound(554, 0.1, 'sine', 0.06), 100);
                    setTimeout(() => playSound(659, 0.1, 'sine', 0.06), 200);
                },
                gameOver: () => {
                    // æ¸¸æˆç»“æŸéŸ³æ•ˆ - ä¸‹é™éŸ³é˜¶
                    playSound(400, 0.3, 'sine', 0.1);
                    setTimeout(() => playSound(300, 0.3, 'sine', 0.1), 200);
                    setTimeout(() => playSound(200, 0.5, 'sine', 0.1), 400);
                },
                powerup: () => {
                    // é“å…·æ”¶é›†éŸ³æ•ˆ - ä¸Šå‡éŸ³é˜¶
                    playSound(600, 0.1, 'sine', 0.08);
                    setTimeout(() => playSound(800, 0.1, 'sine', 0.08), 100);
                    setTimeout(() => playSound(1000, 0.2, 'sine', 0.08), 200);
                },
                bossSpawn: () => {
                    // Bosså‡ºç°éŸ³æ•ˆ - è­¦å‘ŠéŸ³
                    playSound(200, 0.5, 'sawtooth', 0.1);
                    setTimeout(() => playSound(150, 0.5, 'sawtooth', 0.1), 500);
                },
                bossShieldBreak: () => {
                    // æŠ¤ç›¾å‡»ç ´éŸ³æ•ˆ
                    playSound(800, 0.2, 'square', 0.1);
                    setTimeout(() => playSound(1200, 0.2, 'square', 0.1), 100);
                },
                bossPhaseChange: () => {
                    // é˜¶æ®µè½¬æ¢éŸ³æ•ˆ
                    playSound(400, 0.1, 'sine', 0.08);
                    setTimeout(() => playSound(600, 0.1, 'sine', 0.08), 100);
                    setTimeout(() => playSound(800, 0.2, 'sine', 0.08), 200);
                }
            };
            
            // æ˜Ÿæ˜ŸèƒŒæ™¯
            let stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 2 + 1
                });
            }
            
            // é”®ç›˜çŠ¶æ€
            const keys = {
                ArrowLeft: false,
                ArrowRight: false,
                ' ': false
            };
            
            // é”®ç›˜äº‹ä»¶ç›‘å¬
            document.addEventListener('keydown', (e) => {
                if (e.key in keys) {
                    keys[e.key] = true;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.key in keys) {
                    keys[e.key] = false;
                    e.preventDefault();
                }
            });
            
            // ç»˜åˆ¶ç©å®¶é£æœº
            function drawPlayer() {
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                
                // æ— æ•ŒçŠ¶æ€é—ªçƒæ•ˆæœ
                if (player.invulnerable) {
                    player.flashTime += 16;
                    if (Math.floor(player.flashTime / 100) % 2 === 0) {
                        return; // é—ªçƒæ—¶è·³è¿‡ç»˜åˆ¶
                    }
                }
                
                // ç»˜åˆ¶é£èˆ¹ä¸»ä½“ - æ›´é…·ç‚«çš„è®¾è®¡
                ctx.save();
                ctx.translate(centerX, centerY);
                
                // ä¸»ä½“æœºèº«
                ctx.fillStyle = '#00b7ff';
                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(-15, 20);
                ctx.lineTo(-8, 25);
                ctx.lineTo(8, 25);
                ctx.lineTo(15, 20);
                ctx.closePath();
                ctx.fill();
                
                // æœºç¿¼
                ctx.fillStyle = '#0099cc';
                ctx.beginPath();
                ctx.moveTo(-15, 5);
                ctx.lineTo(-25, 15);
                ctx.lineTo(-15, 20);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(15, 5);
                ctx.lineTo(25, 15);
                ctx.lineTo(15, 20);
                ctx.closePath();
                ctx.fill();
                
                // é©¾é©¶èˆ±
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, -5, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // å¼•æ“å…‰æ•ˆ - æ›´ç‚«é…·çš„ç²’å­æ•ˆæœ
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.moveTo(-8, 25);
                ctx.lineTo(-12, 35);
                ctx.lineTo(-4, 30);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(8, 25);
                ctx.lineTo(12, 35);
                ctx.lineTo(4, 30);
                ctx.closePath();
                ctx.fill();
                
                // å¼•æ“æ ¸å¿ƒ
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(-6, 27, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(6, 27, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            // ç»˜åˆ¶å­å¼¹
            function drawBullets() {
                player.bullets.forEach((bullet, index) => {
                    // ç§»åŠ¨å­å¼¹
                    bullet.y -= bullet.speed;
                    
                    // ç§»é™¤è¶…å‡ºç”»å¸ƒçš„å­å¼¹
                    if (bullet.y < 0) {
                        player.bullets.splice(index, 1);
                        return;
                    }
                    
                    // ç»˜åˆ¶å­å¼¹
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // ç»˜åˆ¶æ•Œæœº
            function drawEnemies() {
                enemies.forEach((enemy, index) => {
                    // ç§»åŠ¨æ•Œæœº
                    enemy.y += enemy.speed;
                    
                    // ç§»é™¤è¶…å‡ºç”»å¸ƒçš„æ•Œæœº
                    if (enemy.y > canvas.height) {
                        enemies.splice(index, 1);
                        return;
                    }
                    
                    // ç»˜åˆ¶æ•Œæœº
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y);
                    ctx.lineTo(enemy.x - enemy.size, enemy.y + enemy.size * 2);
                    ctx.lineTo(enemy.x + enemy.size, enemy.y + enemy.size * 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // ç»˜åˆ¶æ•Œæœºé©¾é©¶èˆ±
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y + enemy.size / 2, enemy.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // ç»˜åˆ¶æ˜Ÿæ˜ŸèƒŒæ™¯
            function drawStars() {
                ctx.fillStyle = '#ffffff';
                stars.forEach(star => {
                    star.y += star.speed / 2;
                    if (star.y > canvas.height) {
                        star.y = 0;
                        star.x = Math.random() * canvas.width;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆ
            function createExplosion(x, y, size = 1) {
                const particleCount = 15 * size;
                for (let i = 0; i < particleCount; i++) {
                    explosions.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1.0,
                        decay: 0.02,
                        size: Math.random() * 4 + 2,
                        color: `hsl(${Math.random() * 60 + 15}, 100%, 50%)` // æ©™çº¢è‰²ç³»
                    });
                }
            }
            
            // ç»˜åˆ¶çˆ†ç‚¸ç‰¹æ•ˆ
            function drawExplosions() {
                explosions.forEach((explosion, index) => {
                    explosion.x += explosion.vx;
                    explosion.y += explosion.vy;
                    explosion.life -= explosion.decay;
                    explosion.vx *= 0.98; // é˜»åŠ›
                    explosion.vy *= 0.98;
                    
                    if (explosion.life <= 0) {
                        explosions.splice(index, 1);
                        return;
                    }
                    
                    ctx.save();
                    ctx.globalAlpha = explosion.life;
                    ctx.fillStyle = explosion.color;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.size * explosion.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
            
            // ç»˜åˆ¶é“å…·
            function drawPowerups() {
                powerups.forEach((powerup, index) => {
                    // ç§»åŠ¨é“å…·
                    powerup.y += powerup.speed;
                    powerup.rotation += 0.1;
                    
                    // ç§»é™¤è¶…å‡ºç”»å¸ƒçš„é“å…·
                    if (powerup.y > canvas.height) {
                        powerups.splice(index, 1);
                        return;
                    }
                    
                    // ç»˜åˆ¶é“å…·
                    ctx.save();
                    ctx.translate(powerup.x + powerup.size / 2, powerup.y + powerup.size / 2);
                    ctx.rotate(powerup.rotation);
                    
                    // é“å…·èƒŒæ™¯
                    ctx.fillStyle = powerup.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, powerup.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // é“å…·è¾¹æ¡†
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // é“å…·ç¬¦å·
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(powerup.symbol, 0, 0);
                    
                    ctx.restore();
                });
            }
            
            // ç»˜åˆ¶è¾…æœº
            function drawWingman() {
                if (!playerPowerups.wingman) return;
                
                const wingmanX = player.x + player.width / 2;
                const wingmanY = player.y - 30;
                
                // è¾…æœºä¸»ä½“
                ctx.fillStyle = '#45b7d1';
                ctx.beginPath();
                ctx.moveTo(wingmanX, wingmanY - 15);
                ctx.lineTo(wingmanX - 10, wingmanY + 10);
                ctx.lineTo(wingmanX + 10, wingmanY + 10);
                ctx.closePath();
                ctx.fill();
                
                // è¾…æœºå¼•æ“
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.moveTo(wingmanX - 8, wingmanY + 10);
                ctx.lineTo(wingmanX - 5, wingmanY + 20);
                ctx.lineTo(wingmanX - 2, wingmanY + 15);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(wingmanX + 8, wingmanY + 10);
                ctx.lineTo(wingmanX + 5, wingmanY + 20);
                ctx.lineTo(wingmanX + 2, wingmanY + 15);
                ctx.closePath();
                ctx.fill();
            }
            
            // ç»˜åˆ¶Boss
            function drawBoss() {
                if (!boss) return;
                
                // Bossä¸»ä½“
                ctx.fillStyle = '#ff073a';
                ctx.beginPath();
                ctx.moveTo(boss.x + boss.width / 2, boss.y);
                ctx.lineTo(boss.x, boss.y + boss.height);
                ctx.lineTo(boss.x + boss.width, boss.y + boss.height);
                ctx.closePath();
                ctx.fill();
                
                // BossæŠ¤ç›¾
                if (boss.shield > 0) {
                    ctx.strokeStyle = '#00b7ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Bossæ ¸å¿ƒ
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Bossç‚®å°
                ctx.fillStyle = '#ff4400';
                ctx.fillRect(boss.x + 10, boss.y + 20, 15, 10);
                ctx.fillRect(boss.x + boss.width - 25, boss.y + 20, 15, 10);
                
                // Bosså¼•æ“
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.moveTo(boss.x + boss.width / 2 - 10, boss.y + boss.height);
                ctx.lineTo(boss.x + boss.width / 2, boss.y + boss.height + 20);
                ctx.lineTo(boss.x + boss.width / 2 + 10, boss.y + boss.height);
                ctx.closePath();
                ctx.fill();
            }
            
            // ç»˜åˆ¶Bossæ”»å‡»
            function drawBossAttacks() {
                if (!boss) return;
                
                // ç»˜åˆ¶Bosså­å¼¹
                boss.bullets.forEach((bullet, index) => {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    
                    // è¾¹ç•Œæ£€æŸ¥ - æ‰©å¤§è¾¹ç•ŒèŒƒå›´
                    if (bullet.x < -50 || bullet.x > canvas.width + 50 || 
                        bullet.y < -50 || bullet.y > canvas.height + 50) {
                        boss.bullets.splice(index, 1);
                        return;
                    }
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // é™åˆ¶Bosså­å¼¹æ•°é‡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                if (boss.bullets.length > 50) {
                    boss.bullets = boss.bullets.slice(-30); // åªä¿ç•™æœ€æ–°çš„30ä¸ª
                }
                
                // ç»˜åˆ¶Bosså¯¼å¼¹
                boss.missiles.forEach((missile, index) => {
                    // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ
                    if (missile.life) {
                        missile.life -= 16; // å‡è®¾60FPS
                        if (missile.life <= 0) {
                            boss.missiles.splice(index, 1);
                            return;
                        }
                    }
                    
                    // æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆå®æ—¶è¿½è¸ªç©å®¶ï¼‰
                    missile.targetX = player.x + player.width / 2;
                    missile.targetY = player.y + player.height / 2;
                    
                    const dx = missile.targetX - missile.x;
                    const dy = missile.targetY - missile.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        // å½’ä¸€åŒ–æ–¹å‘å‘é‡å¹¶åº”ç”¨é€Ÿåº¦
                        const vx = (dx / distance) * missile.speed;
                        const vy = (dy / distance) * missile.speed;
                        missile.x += vx;
                        missile.y += vy;
                    }
                    
                    // è¾¹ç•Œæ£€æŸ¥
                    if (missile.x < -10 || missile.x > canvas.width + 10 || 
                        missile.y < -10 || missile.y > canvas.height + 10) {
                        boss.missiles.splice(index, 1);
                        return;
                    }
                    
                    // ç»˜åˆ¶å¯¼å¼¹
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.arc(missile.x, missile.y, missile.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶å¯¼å¼¹å°¾è¿¹
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(missile.x, missile.y);
                    ctx.lineTo(missile.x - dx * 0.1, missile.y - dy * 0.1);
                    ctx.stroke();
                });
                
                // ç»˜åˆ¶Bossæ¿€å…‰
                boss.lasers.forEach((laser, index) => {
                    // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ
                    if (laser.life) {
                        laser.life -= 16; // å‡è®¾60FPS
                        if (laser.life <= 0) {
                            boss.lasers.splice(index, 1);
                            return;
                        }
                    }
                    
                    if (laser.tracking) {
                        laser.x = player.x + player.width / 2 - laser.width / 2;
                    }
                    
                    // æ ¹æ®å‰©ä½™ç”Ÿå‘½å€¼è°ƒæ•´é€æ˜åº¦
                    const alpha = laser.life ? laser.life / 1000 : 1;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                    ctx.restore();
                });
                
                // é™åˆ¶Bosså¯¼å¼¹å’Œæ¿€å…‰æ•°é‡
                if (boss.missiles.length > 20) {
                    boss.missiles = boss.missiles.slice(-15);
                }
                if (boss.lasers.length > 15) {
                    boss.lasers = boss.lasers.slice(-10);
                }
            }
            
            // ç”Ÿæˆæ•Œæœº
            function spawnEnemy() {
                const size = Math.random() * 15 + 10;
                const enemyType = Math.floor(Math.random() * 3);
                
                let color, points, speed;
                
                switch (enemyType) {
                    case 0: // çº¢è‰²æ•Œæœº - æ…¢é€Ÿï¼Œä½åˆ†
                        color = '#ff3860';
                        points = 10;
                        speed = Math.random() * 1.5 + 1;
                        break;
                    case 1: // ç»¿è‰²æ•Œæœº - ä¸­é€Ÿï¼Œä¸­åˆ†
                        color = '#23d160';
                        points = 20;
                        speed = Math.random() * 2 + 1.5;
                        break;
                    case 2: // è“è‰²æ•Œæœº - å¿«é€Ÿï¼Œé«˜åˆ†
                        color = '#3273dc';
                        points = 50;
                        speed = Math.random() * 2.5 + 2;
                        break;
                }
                
                enemies.push({
                    x: Math.random() * (canvas.width - size * 2) + size,
                    y: -size * 2,
                    size: size,
                    speed: speed,
                    color: color,
                    points: points
                });
            }
            
            // ç”Ÿæˆé“å…·
            function spawnPowerup() {
                const powerupTypes = ['fireRate', 'multiBullet', 'wingman', 'health'];
                const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                
                let color, symbol;
                switch (type) {
                    case 'fireRate':
                        color = '#ff6b35';
                        symbol = 'âš¡';
                        break;
                    case 'multiBullet':
                        color = '#4ecdc4';
                        symbol = 'ğŸ’¥';
                        break;
                    case 'wingman':
                        color = '#45b7d1';
                        symbol = 'ğŸ›¸';
                        break;
                    case 'health':
                        color = '#e74c3c';
                        symbol = 'â¤ï¸';
                        break;
                }
                
                powerups.push({
                    x: Math.random() * (canvas.width - 30) + 15,
                    y: -30,
                    size: 20,
                    speed: 2,
                    color: color,
                    symbol: symbol,
                    type: type,
                    rotation: 0
                });
            }
            
            // ç”ŸæˆBoss
            function spawnBoss() {
                if (bossActive) return;
                
                boss = {
                    x: canvas.width / 2 - 50,
                    y: 50,
                    width: 100,
                    height: 80,
                    maxHealth: 1000,
                    health: 1000,
                    shield: 200,
                    maxShield: 200,
                    phase: 1,
                    speed: 1,
                    direction: 1,
                    lastAttack: 0,
                    attackDelay: 3000, // å¢åŠ æ”»å‡»é—´éš”
                    bullets: [],
                    missiles: [],
                    lasers: [],
                    invulnerable: false,
                    invulnerableTime: 0,
                    phaseChangeTime: 0
                };
                
                bossActive = true;
                sounds.bossSpawn();
            }
            
            // å°„å‡»å‡½æ•°
            function shoot() {
                const currentTime = Date.now();
                const adjustedDelay = player.shootDelay / playerPowerups.fireRate;
                
                if (currentTime - player.lastShot > adjustedDelay) {
                    const centerX = player.x + player.width / 2;
                    const bulletCount = playerPowerups.multiBullet;
                    
                    if (bulletCount === 1) {
                        // å•å‘å­å¼¹
                        player.bullets.push({
                            x: centerX,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                    } else if (bulletCount === 2) {
                        // åŒå‘å­å¼¹
                        player.bullets.push({
                            x: centerX - 8,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                        player.bullets.push({
                            x: centerX + 8,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                    } else if (bulletCount === 3) {
                        // ä¸‰å‘å­å¼¹
                        player.bullets.push({
                            x: centerX,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                        player.bullets.push({
                            x: centerX - 12,
                            y: player.y + 5,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                        player.bullets.push({
                            x: centerX + 12,
                            y: player.y + 5,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                    }
                    
                    player.lastShot = currentTime;
                    sounds.shoot(); // æ’­æ”¾å°„å‡»éŸ³æ•ˆ
                }
            }
            
            // ç¢°æ’æ£€æµ‹
            function checkCollisions() {
                // å­å¼¹ä¸æ•Œæœºç¢°æ’
                player.bullets.forEach((bullet, bulletIndex) => {
                    enemies.forEach((enemy, enemyIndex) => {
                        const dx = bullet.x - enemy.x;
                        const dy = bullet.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < enemy.size + bullet.radius) {
                            // åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆ
                            createExplosion(enemy.x, enemy.y, enemy.size / 10);
                            
                            // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
                            sounds.explosion();
                            
                            // ç§»é™¤å­å¼¹å’Œæ•Œæœº
                            player.bullets.splice(bulletIndex, 1);
                            enemies.splice(enemyIndex, 1);
                            
                            // å¢åŠ åˆ†æ•°
                            score += enemy.points;
                            scoreElement.textContent = score;
                            
                            // æ¯1000åˆ†å‡ä¸€çº§
                            if (score % 1000 < enemy.points && score >= 1000) {
                                level++;
                                levelElement.textContent = level;
                                sounds.levelUp(); // æ’­æ”¾å‡çº§éŸ³æ•ˆ
                            }
                        }
                    });
                });
                
                // ç©å®¶ä¸é“å…·ç¢°æ’
                powerups.forEach((powerup, index) => {
                    const dx = (player.x + player.width / 2) - (powerup.x + powerup.size / 2);
                    const dy = (player.y + player.height / 2) - (powerup.y + powerup.size / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.width / 2 + powerup.size) {
                        // æ”¶é›†é“å…·
                        collectPowerup(powerup.type);
                        powerups.splice(index, 1);
                        sounds.powerup();
                    }
                });
                
                // ç©å®¶ä¸æ•Œæœºç¢°æ’ - å¢åŠ æ— æ•Œæ—¶é—´æœºåˆ¶
                if (!player.invulnerable) {
                    enemies.forEach((enemy, index) => {
                        const dx = (player.x + player.width / 2) - enemy.x;
                        const dy = (player.y + player.height / 2) - (enemy.y + enemy.size);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < player.width / 2 + enemy.size) {
                            // åˆ›å»ºçˆ†ç‚¸ç‰¹æ•ˆ
                            createExplosion(enemy.x, enemy.y, enemy.size / 10);
                            
                            // æ’­æ”¾å‡»ä¸­éŸ³æ•ˆ
                            sounds.hit();
                            
                            // ç§»é™¤æ•Œæœº
                            enemies.splice(index, 1);
                            
                            // æ£€æŸ¥æ˜¯å¦æœ‰è¾…æœºä¿æŠ¤
                            if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                // è¾…æœºæ‰¿å—ä¼¤å®³
                                playerPowerups.wingmanHealth--;
                                if (playerPowerups.wingmanHealth <= 0) {
                                    playerPowerups.wingman = false;
                                }
                            } else {
                                // å‡å°‘ç”Ÿå‘½å€¼
                                lives--;
                                livesElement.textContent = lives;
                                
                                // å¯åŠ¨æ— æ•Œæ—¶é—´
                                player.invulnerable = true;
                                player.invulnerableTime = Date.now();
                                player.flashTime = 0;
                                
                                // æ£€æŸ¥æ¸¸æˆç»“æŸ
                                if (lives <= 0) {
                                    gameOver = true;
                                    finalScoreElement.textContent = score;
                                    gameOverElement.style.display = 'block';
                                    sounds.gameOver(); // æ’­æ”¾æ¸¸æˆç»“æŸéŸ³æ•ˆ
                                    stopBGM(); // åœæ­¢èƒŒæ™¯éŸ³ä¹
                                    cancelAnimationFrame(animationId);
                                }
                            }
                        }
                    });
                }
                
                // Bossç›¸å…³ç¢°æ’æ£€æµ‹
                if (bossActive && boss) {
                    // ç©å®¶å­å¼¹ä¸Bossç¢°æ’
                    player.bullets.forEach((bullet, bulletIndex) => {
                        // å†æ¬¡æ£€æŸ¥Bossæ˜¯å¦å­˜åœ¨ï¼ˆé˜²æ­¢åœ¨å¾ªç¯ä¸­Bossè¢«é”€æ¯ï¼‰
                        if (!boss) return;
                        
                        const dx = bullet.x - (boss.x + boss.width / 2);
                        const dy = bullet.y - (boss.y + boss.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < boss.width / 2 + bullet.radius) {
                            // ç§»é™¤å­å¼¹
                            player.bullets.splice(bulletIndex, 1);
                            
                            if (boss.shield > 0) {
                                // æ”»å‡»æŠ¤ç›¾
                                boss.shield -= 10;
                                if (boss.shield <= 0) {
                                    sounds.bossShieldBreak();
                                }
                            } else {
                                // æ”»å‡»Bossæœ¬ä½“
                                boss.health -= 20;
                                createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, 2);
                                
                                if (boss.health <= 0) {
                                    // Bossæ­»äº¡
                                    createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, 5);
                                    score += 1000; // Bosså¥–åŠ±åˆ†æ•°
                                    scoreElement.textContent = score;
                                    bossActive = false;
                                    boss = null;
                                    sounds.explosion();
                                    return; // ç«‹å³è¿”å›ï¼Œé¿å…ç»§ç»­å¤„ç†
                                }
                            }
                        }
                    });
                    
                    // ç©å®¶ä¸Bossæ”»å‡»ç¢°æ’
                    if (!player.invulnerable && boss) {
                        // Bosså­å¼¹ç¢°æ’
                        boss.bullets.forEach((bullet, index) => {
                            // å†æ¬¡æ£€æŸ¥Bossæ˜¯å¦å­˜åœ¨
                            if (!boss) return;
                            
                            const dx = (player.x + player.width / 2) - bullet.x;
                            const dy = (player.y + player.height / 2) - bullet.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < player.width / 2 + bullet.radius) {
                                boss.bullets.splice(index, 1);
                                createExplosion(bullet.x, bullet.y, 1);
                                sounds.hit();
                                
                                // å¤„ç†ä¼¤å®³
                                if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                    playerPowerups.wingmanHealth--;
                                    if (playerPowerups.wingmanHealth <= 0) {
                                        playerPowerups.wingman = false;
                                    }
                                } else {
                                    lives--;
                                    livesElement.textContent = lives;
                                    player.invulnerable = true;
                                    player.invulnerableTime = Date.now();
                                    player.flashTime = 0;
                                    
                                    if (lives <= 0) {
                                        gameOver = true;
                                        finalScoreElement.textContent = score;
                                        gameOverElement.style.display = 'block';
                                        sounds.gameOver();
                                        stopBGM();
                                        cancelAnimationFrame(animationId);
                                    }
                                }
                            }
                        });
                        
                        // Bosså¯¼å¼¹ç¢°æ’
                        if (boss && boss.missiles) {
                            boss.missiles.forEach((missile, index) => {
                                // å†æ¬¡æ£€æŸ¥Bossæ˜¯å¦å­˜åœ¨
                                if (!boss) return;
                                
                                const dx = (player.x + player.width / 2) - missile.x;
                                const dy = (player.y + player.height / 2) - missile.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < player.width / 2 + missile.radius) {
                                    boss.missiles.splice(index, 1);
                                    createExplosion(missile.x, missile.y, 2);
                                    sounds.explosion();
                                    
                                    // å¤„ç†ä¼¤å®³
                                    if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                        playerPowerups.wingmanHealth--;
                                        if (playerPowerups.wingmanHealth <= 0) {
                                            playerPowerups.wingman = false;
                                        }
                                    } else {
                                        lives--;
                                        livesElement.textContent = lives;
                                        player.invulnerable = true;
                                        player.invulnerableTime = Date.now();
                                        player.flashTime = 0;
                                        
                                        if (lives <= 0) {
                                            gameOver = true;
                                            finalScoreElement.textContent = score;
                                            gameOverElement.style.display = 'block';
                                            sounds.gameOver();
                                            stopBGM();
                                            cancelAnimationFrame(animationId);
                                        }
                                    }
                                }
                            });
                        }
                        
                        // Bossæ¿€å…‰ç¢°æ’
                        if (boss && boss.lasers) {
                            boss.lasers.forEach((laser, index) => {
                                // å†æ¬¡æ£€æŸ¥Bossæ˜¯å¦å­˜åœ¨
                                if (!boss) return;
                                
                                if (player.x < laser.x + laser.width && 
                                    player.x + player.width > laser.x && 
                                    player.y < laser.y + laser.height && 
                                    player.y + player.height > laser.y) {
                                    
                                    // å¤„ç†ä¼¤å®³
                                    if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                        playerPowerups.wingmanHealth--;
                                        if (playerPowerups.wingmanHealth <= 0) {
                                            playerPowerups.wingman = false;
                                        }
                                    } else {
                                        lives--;
                                        livesElement.textContent = lives;
                                        player.invulnerable = true;
                                        player.invulnerableTime = Date.now();
                                        player.flashTime = 0;
                                        
                                        if (lives <= 0) {
                                            gameOver = true;
                                            finalScoreElement.textContent = score;
                                            gameOverElement.style.display = 'block';
                                            sounds.gameOver();
                                            stopBGM();
                                            cancelAnimationFrame(animationId);
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            // æ”¶é›†é“å…·
            function collectPowerup(type) {
                switch (type) {
                    case 'fireRate':
                        playerPowerups.fireRate = Math.min(playerPowerups.fireRate + 0.5, 3);
                        break;
                    case 'multiBullet':
                        playerPowerups.multiBullet = Math.min(playerPowerups.multiBullet + 1, 3);
                        break;
                    case 'wingman':
                        playerPowerups.wingman = true;
                        playerPowerups.wingmanHealth = 3; // è¾…æœºæœ‰3ç‚¹ç”Ÿå‘½å€¼
                        break;
                    case 'health':
                        lives = Math.min(lives + 1, 5); // æœ€å¤š5æ¡ç”Ÿå‘½
                        livesElement.textContent = lives;
                        break;
                }
            }
            
            // Bossæ”»å‡»å‡½æ•°
            function bossAttack() {
                if (!boss || boss.invulnerable) return;
                
                const currentTime = Date.now();
                if (currentTime - boss.lastAttack < boss.attackDelay) return;
                
                boss.lastAttack = currentTime;
                
                switch (boss.phase) {
                    case 1:
                        // é˜¶æ®µ1ï¼šåŸºç¡€æ”»å‡»
                        bossBasicAttack();
                        break;
                    case 2:
                        // é˜¶æ®µ2ï¼šå¼ºåŒ–æ”»å‡»
                        bossEnhancedAttack();
                        break;
                    case 3:
                        // é˜¶æ®µ3ï¼šç‹‚æš´æ”»å‡»
                        bossBerserkAttack();
                        break;
                }
            }
            
            // BossåŸºç¡€æ”»å‡»
            function bossBasicAttack() {
                // æ¿€å…‰æ‰«å°„
                boss.lasers.push({
                    x: boss.x,
                    y: boss.y + boss.height,
                    width: 4,
                    height: canvas.height,
                    speed: 0,
                    damage: 1,
                    life: 1000 // 1ç§’åæ¶ˆå¤±
                });
                
                boss.lasers.push({
                    x: boss.x + boss.width - 4,
                    y: boss.y + boss.height,
                    width: 4,
                    height: canvas.height,
                    speed: 0,
                    damage: 1,
                    life: 1000 // 1ç§’åæ¶ˆå¤±
                });
                
                // å¯¼å¼¹é½å°„
                for (let i = 0; i < 3; i++) {
                    boss.missiles.push({
                        x: boss.x + boss.width / 2 + (i - 1) * 20, // åˆ†æ•£å‘å°„ä½ç½®
                        y: boss.y + boss.height,
                        radius: 4,
                        speed: 2.5, // ç¨å¾®é™ä½é€Ÿåº¦è®©è¿½è¸ªæ›´æ˜æ˜¾
                        targetX: player.x + player.width / 2,
                        targetY: player.y + player.height / 2,
                        damage: 2,
                        life: 3000 // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
                    });
                }
                
                // å¬å”¤å°å…µ
                for (let i = 0; i < 2; i++) {
                    enemies.push({
                        x: boss.x + (i * 40),
                        y: boss.y + boss.height,
                        size: 15,
                        speed: 2,
                        color: '#ff3860',
                        points: 10
                    });
                }
            }
            
            // Bosså¼ºåŒ–æ”»å‡»
            function bossEnhancedAttack() {
                // ç¯å½¢å¼¹å¹•
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    boss.bullets.push({
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        radius: 3,
                        speed: 2,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2,
                        damage: 1
                    });
                }
                
                // æ¿€å…‰ç½‘
                for (let i = 0; i < 5; i++) {
                    boss.lasers.push({
                        x: (i * canvas.width / 4),
                        y: boss.y + boss.height,
                        width: 2,
                        height: canvas.height,
                        speed: 0,
                        damage: 1,
                        life: 1500 // 1.5ç§’åæ¶ˆå¤±
                    });
                }
                
                // å†²é”‹æ”»å‡»
                boss.speed = 3;
                boss.direction = player.x < boss.x ? -1 : 1;
            }
            
            // Bossç‹‚æš´æ”»å‡»
            function bossBerserkAttack() {
                // å…¨å±å¼¹å¹• - å‡å°‘å­å¼¹æ•°é‡
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    boss.bullets.push({
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        radius: 4,
                        speed: 3,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        damage: 2
                    });
                }
                
                // è¿½è¸ªæ¿€å…‰
                boss.lasers.push({
                    x: boss.x + boss.width / 2,
                    y: boss.y + boss.height,
                    width: 6,
                    height: canvas.height,
                    speed: 0,
                    damage: 2,
                    tracking: true,
                    life: 800 // 0.8ç§’åæ¶ˆå¤±
                });
                
                // è‡ªçˆ†å°å…µ
                for (let i = 0; i < 3; i++) {
                    enemies.push({
                        x: boss.x + (i * 30),
                        y: boss.y + boss.height,
                        size: 12,
                        speed: 4,
                        color: '#ff0000',
                        points: 20,
                        explosive: true
                    });
                }
            }
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            function update() {
                // å¤„ç†æ— æ•Œæ—¶é—´
                if (player.invulnerable) {
                    if (Date.now() - player.invulnerableTime > player.invulnerableDuration) {
                        player.invulnerable = false;
                        player.flashTime = 0;
                    }
                }
                
                // å¹³æ»‘ç§»åŠ¨ç©å®¶
                let targetVelocity = 0;
                
                if (keys.ArrowLeft) {
                    targetVelocity = -player.maxSpeed;
                } else if (keys.ArrowRight) {
                    targetVelocity = player.maxSpeed;
                }
                
                // åº”ç”¨åŠ é€Ÿåº¦å’Œå‡é€Ÿåº¦
                if (targetVelocity !== 0) {
                    // åŠ é€Ÿ
                    if (Math.abs(player.velocity) < Math.abs(targetVelocity)) {
                        player.velocity += targetVelocity > 0 ? player.acceleration : -player.acceleration;
                    } else {
                        player.velocity = targetVelocity;
                    }
                } else {
                    // å‡é€Ÿ
                    if (player.velocity > 0) {
                        player.velocity = Math.max(0, player.velocity - player.deceleration);
                    } else if (player.velocity < 0) {
                        player.velocity = Math.min(0, player.velocity + player.deceleration);
                    }
                }
                
                // åº”ç”¨ç§»åŠ¨
                player.x += player.velocity;
                
                // è¾¹ç•Œæ£€æŸ¥
                if (player.x < 0) {
                    player.x = 0;
                    player.velocity = 0;
                } else if (player.x > canvas.width - player.width) {
                    player.x = canvas.width - player.width;
                    player.velocity = 0;
                }
                
                // å°„å‡»
                if (keys[' ']) {
                    shoot();
                }
                
                // éšæœºç”Ÿæˆæ•Œæœº
                if (Math.random() < 0.03) {
                    spawnEnemy();
                }
                
                // éšæœºç”Ÿæˆé“å…·
                if (Math.random() < 0.005) { // é“å…·ç”Ÿæˆæ¦‚ç‡è¾ƒä½
                    spawnPowerup();
                }
                
                // Bossé€»è¾‘
                if (bossActive && boss) {
                    // Bossç§»åŠ¨
                    boss.x += boss.speed * boss.direction;
                    if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
                        boss.direction *= -1;
                    }
                    
                    // Bossæ”»å‡»
                    bossAttack();
                    
                    // Bossé˜¶æ®µè½¬æ¢
                    if (boss.health <= 700 && boss.phase === 1) {
                        boss.phase = 2;
                        boss.attackDelay = 2000; // å¢åŠ æ”»å‡»é—´éš”
                        boss.invulnerable = true;
                        boss.phaseChangeTime = Date.now();
                        sounds.bossPhaseChange();
                    } else if (boss.health <= 300 && boss.phase === 2) {
                        boss.phase = 3;
                        boss.attackDelay = 1500; // å¢åŠ æ”»å‡»é—´éš”
                        boss.invulnerable = true;
                        boss.phaseChangeTime = Date.now();
                        sounds.bossPhaseChange();
                    }
                    
                    // é˜¶æ®µè½¬æ¢æ— æ•Œæ—¶é—´
                    if (boss.invulnerable && Date.now() - boss.phaseChangeTime > 2000) {
                        boss.invulnerable = false;
                    }
                } else if (!bossActive && score - lastBossScore >= bossSpawnScore) {
                    // ç”ŸæˆBoss
                    spawnBoss();
                    lastBossScore = score;
                }
                
                // æ£€æŸ¥ç¢°æ’
                checkCollisions();
            }
            
            // ç»˜åˆ¶æ¸¸æˆ
            function draw() {
                // æ¸…é™¤ç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶èƒŒæ™¯å’Œæ¸¸æˆå…ƒç´ 
                drawStars();
                drawPlayer();
                drawWingman(); // ç»˜åˆ¶è¾…æœº
                drawBullets();
                drawEnemies();
                drawPowerups(); // ç»˜åˆ¶é“å…·
                drawBoss(); // ç»˜åˆ¶Boss
                drawBossAttacks(); // ç»˜åˆ¶Bossæ”»å‡»
                drawExplosions();
            }
            
            // æ¸¸æˆå¾ªç¯
            function gameLoop() {
                if (!gameOver) {
                    update();
                    draw();
                    animationId = requestAnimationFrame(gameLoop);
                }
            }
            
            // åˆå§‹åŒ–æ¸¸æˆ
            function initGame() {
                score = 0;
                lives = 3;
                level = 1;
                gameOver = false;
                
                scoreElement.textContent = score;
                livesElement.textContent = lives;
                levelElement.textContent = level;
                
                player.x = canvas.width / 2 - 25;
                player.y = canvas.height - 70;
                player.bullets = [];
                player.velocity = 0; // é‡ç½®é€Ÿåº¦
                player.invulnerable = false;
                player.invulnerableTime = 0;
                player.flashTime = 0;
                
                enemies = [];
                explosions = [];
                powerups = [];
                playerPowerups = {
                    fireRate: 1,
                    multiBullet: 1,
                    wingman: false,
                    wingmanHealth: 0
                };
                boss = null;
                bossActive = false;
                lastBossScore = 0;
                
                gameOverElement.style.display = 'none';
                
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                // è‡ªåŠ¨å¯åŠ¨BGM
                setTimeout(() => {
                    if (bgmEnabled) {
                        startBGM();
                    }
                }, 1000);
                
                gameLoop();
            }
            
            // éŸ³æ•ˆå¼€å…³
            const audioToggle = document.getElementById('audioToggle');
            audioToggle.addEventListener('click', () => {
                audioEnabled = !audioEnabled;
                audioToggle.textContent = audioEnabled ? 'ğŸ”Š éŸ³æ•ˆå¼€å¯' : 'ğŸ”‡ éŸ³æ•ˆå…³é—­';
                audioToggle.style.background = audioEnabled ? 
                    'linear-gradient(135deg, #3498db, #2980b9)' : 
                    'linear-gradient(135deg, #95a5a6, #7f8c8d)';
            });
            
            // BGMå¼€å…³
            const bgmToggle = document.getElementById('bgmToggle');
            bgmToggle.addEventListener('click', () => {
                bgmEnabled = !bgmEnabled;
                bgmToggle.textContent = bgmEnabled ? 'ğŸµ BGMå¼€å¯' : 'ğŸ”‡ BGMå…³é—­';
                bgmToggle.style.background = bgmEnabled ? 
                    'linear-gradient(135deg, #e74c3c, #c0392b)' : 
                    'linear-gradient(135deg, #95a5a6, #7f8c8d)';
                
                if (bgmEnabled) {
                    startBGM();
                } else {
                    stopBGM();
                }
            });
            
            // é‡æ–°å¼€å§‹æ¸¸æˆ
            restartBtn.addEventListener('click', initGame);
            
            // å¼€å§‹æ¸¸æˆ
            initGame();
            
            
        });
    </script>
</body>

</html>
