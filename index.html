<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>太空战机 - HTML5飞机大战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            overflow: hidden;
            padding: 20px;
        }
        
        .game-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 10px #00b7ff, 0 0 20px #00b7ff;
            color: #fff;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
        }
        
        canvas {
            background: linear-gradient(180deg, #0a0a2a, #1c1c3a);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 183, 255, 0.5);
            display: block;
            margin: 0 auto;
            border: 2px solid #00b7ff;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 800px;
            margin-bottom: 15px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 183, 255, 0.3);
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #00b7ff;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
            color: #00b7ff;
            font-size: 1rem;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
            display: none;
            z-index: 100;
            border: 2px solid #ff073a;
        }
        
        .game-over h2 {
            font-size: 2.5rem;
            color: #ff073a;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff073a;
        }
        
        .final-score {
            font-size: 1.8rem;
            margin-bottom: 25px;
            color: #fff;
        }
        
        .restart-btn {
            padding: 12px 25px;
            background: linear-gradient(135deg, #ff073a, #ff4d00);
            border: none;
            border-radius: 50px;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 7, 58, 0.5);
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 7, 58, 0.7);
        }
        
        .instructions {
            max-width: 800px;
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            text-align: center;
        }
        
        .instructions h3 {
            color: #00b7ff;
            margin-bottom: 15px;
        }
        
        .instructions p {
            margin: 8px 0;
            color: #ccc;
        }
    </style>
</head>
<body>
    <h1 class="game-title">太空战机</h1>
    
    <div class="game-stats">
        <div class="stat">
            <div class="stat-label">分数</div>
            <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat">
            <div class="stat-label">生命值</div>
            <div class="stat-value" id="lives">3</div>
        </div>
        <div class="stat">
            <div class="stat-label">等级</div>
            <div class="stat-value" id="level">1</div>
        </div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        
        <div class="game-over" id="gameOver">
            <h2>游戏结束</h2>
            <div class="final-score">最终得分: <span id="finalScore">0</span></div>
            <button class="restart-btn" id="restartBtn">重新开始</button>
        </div>
    </div>
    
    <div class="controls">
        <p>控制: ← → 移动飞船 | 空格键射击</p>
        <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: center;">
            <button id="audioToggle" style="padding: 8px 15px; background: linear-gradient(135deg, #3498db, #2980b9); border: none; border-radius: 20px; color: white; cursor: pointer;">🔊 音效开启</button>
            <button id="bgmToggle" style="padding: 8px 15px; background: linear-gradient(135deg, #e74c3c, #c0392b); border: none; border-radius: 20px; color: white; cursor: pointer;">🎵 BGM开启</button>
        </div>
    </div>
    
    <div class="instructions">
        <h3>游戏说明</h3>
        <p>击落敌机获得分数，每1000分升一级</p>
        <p>红色敌机: 10分 | 绿色敌机: 20分 | 蓝色敌机: 50分</p>
        <p>避免与敌机相撞，你有3条生命</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 获取Canvas和Context
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // 游戏状态元素
            const scoreElement = document.getElementById('score');
            const livesElement = document.getElementById('lives');
            const levelElement = document.getElementById('level');
            const gameOverElement = document.getElementById('gameOver');
            const finalScoreElement = document.getElementById('finalScore');
            const restartBtn = document.getElementById('restartBtn');
            
            // 游戏变量
            let score = 0;
            let lives = 3;
            let level = 1;
            let gameOver = false;
            let animationId;
            
            // 玩家飞机
            const player = {
                x: canvas.width / 2 - 25,
                y: canvas.height - 70,
                width: 50,
                height: 60,
                speed: 4, // 降低基础速度
                maxSpeed: 6, // 最大速度
                acceleration: 0.3, // 加速度
                deceleration: 0.2, // 减速度
                velocity: 0, // 当前速度
                color: '#00b7ff',
                bullets: [],
                lastShot: 0,
                shootDelay: 300,
                invulnerable: false,
                invulnerableTime: 0,
                invulnerableDuration: 2000, // 2秒无敌时间
                flashTime: 0
            };
            
            // 敌机数组
            let enemies = [];
            
            // 爆炸特效数组
            let explosions = [];
            
            // 道具系统
            let powerups = [];
            let playerPowerups = {
                fireRate: 1, // 射速倍数
                multiBullet: 1, // 子弹数量
                wingman: false, // 是否有辅机
                wingmanHealth: 0 // 辅机生命值
            };
            
            // Boss系统
            let boss = null;
            let bossActive = false;
            let bossSpawnScore = 5000; // Boss出现分数间隔
            let lastBossScore = 0;
            
            // 音频系统
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let audioEnabled = true;
            let bgmEnabled = true;
            let bgmPlaying = false;
            
            // 音效生成函数
            function playSound(frequency, duration, type = 'sine', volume = 0.1) {
                if (!audioEnabled) return;
                
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Audio not available:', e);
                }
            }
            
            // 背景音乐系统
            let bgmOscillators = [];
            let bgmGainNode;
            
            function startBGM() {
                if (!bgmEnabled || bgmPlaying) return;
                
                try {
                    bgmGainNode = audioContext.createGain();
                    bgmGainNode.connect(audioContext.destination);
                    bgmGainNode.gain.setValueAtTime(0.02, audioContext.currentTime); // 很低的音量
                    
                    // 更丰富的太空主题背景音乐
                    const melodies = [
                        [440, 523, 659, 523, 440, 349, 392, 440], // A-C-E-C-A-F-G-A
                        [523, 659, 784, 659, 523, 440, 392, 349], // C-E-G-E-C-A-G-F
                        [349, 392, 440, 523, 659, 523, 440, 392]  // F-G-A-C-E-C-A-G
                    ];
                    
                    const bassPatterns = [
                        [220, 220, 196, 196, 220, 220, 196, 196], // 基础低音
                        [196, 196, 174, 174, 196, 196, 174, 174], // 变化低音
                        [220, 196, 174, 196, 220, 196, 174, 196]  // 复杂低音
                    ];
                    
                    const harmonyPatterns = [
                        [330, 392, 494, 392, 330, 262, 294, 330], // 基础和声
                        [392, 494, 587, 494, 392, 330, 294, 262], // 高和声
                        [262, 294, 330, 392, 494, 392, 330, 294]  // 低和声
                    ];
                    
                    let patternIndex = 0;
                    let noteIndex = 0;
                    let beatCount = 0;
                    
                    function playBGMNote() {
                        if (!bgmPlaying) return;
                        
                        const currentTime = audioContext.currentTime;
                        const noteDuration = 0.6;
                        const currentMelody = melodies[patternIndex];
                        const currentBass = bassPatterns[patternIndex];
                        const currentHarmony = harmonyPatterns[patternIndex];
                        
                        // 主旋律 - 带颤音效果
                        const melodyOsc = audioContext.createOscillator();
                        melodyOsc.type = 'sine';
                        melodyOsc.frequency.setValueAtTime(currentMelody[noteIndex], currentTime);
                        
                        // 添加颤音
                        const melodyLFO = audioContext.createOscillator();
                        const melodyLFOGain = audioContext.createGain();
                        melodyLFO.frequency.setValueAtTime(5, currentTime);
                        melodyLFOGain.gain.setValueAtTime(3, currentTime);
                        melodyLFO.connect(melodyLFOGain);
                        melodyLFOGain.connect(melodyOsc.frequency);
                        
                        melodyOsc.connect(bgmGainNode);
                        melodyOsc.start(currentTime);
                        melodyOsc.stop(currentTime + noteDuration);
                        melodyLFO.start(currentTime);
                        melodyLFO.stop(currentTime + noteDuration);
                        
                        // 低音 - 带包络
                        const bassOsc = audioContext.createOscillator();
                        bassOsc.type = 'triangle';
                        bassOsc.frequency.setValueAtTime(currentBass[noteIndex], currentTime);
                        
                        const bassGain = audioContext.createGain();
                        bassGain.gain.setValueAtTime(0.3, currentTime);
                        bassGain.gain.exponentialRampToValueAtTime(0.1, currentTime + noteDuration);
                        bassOsc.connect(bassGain);
                        bassGain.connect(bgmGainNode);
                        bassOsc.start(currentTime);
                        bassOsc.stop(currentTime + noteDuration);
                        
                        // 和声 - 带延迟效果
                        const harmonyOsc = audioContext.createOscillator();
                        harmonyOsc.type = 'sawtooth';
                        harmonyOsc.frequency.setValueAtTime(currentHarmony[noteIndex], currentTime);
                        
                        const harmonyGain = audioContext.createGain();
                        harmonyGain.gain.setValueAtTime(0.2, currentTime);
                        harmonyGain.gain.exponentialRampToValueAtTime(0.05, currentTime + noteDuration);
                        harmonyOsc.connect(harmonyGain);
                        harmonyGain.connect(bgmGainNode);
                        harmonyOsc.start(currentTime);
                        harmonyOsc.stop(currentTime + noteDuration);
                        
                        // 添加鼓点效果（每4拍）
                        if (beatCount % 4 === 0) {
                            const drumOsc = audioContext.createOscillator();
                            drumOsc.type = 'square';
                            drumOsc.frequency.setValueAtTime(80, currentTime);
                            
                            const drumGain = audioContext.createGain();
                            drumGain.gain.setValueAtTime(0.1, currentTime);
                            drumGain.gain.exponentialRampToValueAtTime(0.01, currentTime + 0.1);
                            drumOsc.connect(drumGain);
                            drumGain.connect(bgmGainNode);
                            drumOsc.start(currentTime);
                            drumOsc.stop(currentTime + 0.1);
                        }
                        
                        noteIndex = (noteIndex + 1) % currentMelody.length;
                        beatCount++;
                        
                        // 每32拍切换模式
                        if (beatCount % 32 === 0) {
                            patternIndex = (patternIndex + 1) % melodies.length;
                        }
                        
                        setTimeout(playBGMNote, noteDuration * 1000);
                    }
                    
                    bgmPlaying = true;
                    playBGMNote();
                } catch (e) {
                    console.log('BGM not available:', e);
                }
            }
            
            function stopBGM() {
                bgmPlaying = false;
                if (bgmGainNode) {
                    bgmGainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                }
            }
            
            // 预定义音效
            const sounds = {
                shoot: () => playSound(400, 0.05, 'sine', 0.02),
                explosion: () => {
                    // 爆炸音效 - 低频噪音
                    playSound(100, 0.3, 'sawtooth', 0.1);
                    setTimeout(() => playSound(150, 0.2, 'triangle', 0.08), 50);
                },
                hit: () => playSound(200, 0.2, 'sine', 0.08),
                levelUp: () => {
                    // 升级音效 - 上升音阶
                    playSound(440, 0.1, 'sine', 0.06);
                    setTimeout(() => playSound(554, 0.1, 'sine', 0.06), 100);
                    setTimeout(() => playSound(659, 0.1, 'sine', 0.06), 200);
                },
                gameOver: () => {
                    // 游戏结束音效 - 下降音阶
                    playSound(400, 0.3, 'sine', 0.1);
                    setTimeout(() => playSound(300, 0.3, 'sine', 0.1), 200);
                    setTimeout(() => playSound(200, 0.5, 'sine', 0.1), 400);
                },
                powerup: () => {
                    // 道具收集音效 - 上升音阶
                    playSound(600, 0.1, 'sine', 0.08);
                    setTimeout(() => playSound(800, 0.1, 'sine', 0.08), 100);
                    setTimeout(() => playSound(1000, 0.2, 'sine', 0.08), 200);
                },
                bossSpawn: () => {
                    // Boss出现音效 - 警告音
                    playSound(200, 0.5, 'sawtooth', 0.1);
                    setTimeout(() => playSound(150, 0.5, 'sawtooth', 0.1), 500);
                },
                bossShieldBreak: () => {
                    // 护盾击破音效
                    playSound(800, 0.2, 'square', 0.1);
                    setTimeout(() => playSound(1200, 0.2, 'square', 0.1), 100);
                },
                bossPhaseChange: () => {
                    // 阶段转换音效
                    playSound(400, 0.1, 'sine', 0.08);
                    setTimeout(() => playSound(600, 0.1, 'sine', 0.08), 100);
                    setTimeout(() => playSound(800, 0.2, 'sine', 0.08), 200);
                }
            };
            
            // 星星背景
            let stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 2 + 1
                });
            }
            
            // 键盘状态
            const keys = {
                ArrowLeft: false,
                ArrowRight: false,
                ' ': false
            };
            
            // 键盘事件监听
            document.addEventListener('keydown', (e) => {
                if (e.key in keys) {
                    keys[e.key] = true;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.key in keys) {
                    keys[e.key] = false;
                    e.preventDefault();
                }
            });
            
            // 绘制玩家飞机
            function drawPlayer() {
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                
                // 无敌状态闪烁效果
                if (player.invulnerable) {
                    player.flashTime += 16;
                    if (Math.floor(player.flashTime / 100) % 2 === 0) {
                        return; // 闪烁时跳过绘制
                    }
                }
                
                // 绘制飞船主体 - 更酷炫的设计
                ctx.save();
                ctx.translate(centerX, centerY);
                
                // 主体机身
                ctx.fillStyle = '#00b7ff';
                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(-15, 20);
                ctx.lineTo(-8, 25);
                ctx.lineTo(8, 25);
                ctx.lineTo(15, 20);
                ctx.closePath();
                ctx.fill();
                
                // 机翼
                ctx.fillStyle = '#0099cc';
                ctx.beginPath();
                ctx.moveTo(-15, 5);
                ctx.lineTo(-25, 15);
                ctx.lineTo(-15, 20);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(15, 5);
                ctx.lineTo(25, 15);
                ctx.lineTo(15, 20);
                ctx.closePath();
                ctx.fill();
                
                // 驾驶舱
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, -5, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // 引擎光效 - 更炫酷的粒子效果
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.moveTo(-8, 25);
                ctx.lineTo(-12, 35);
                ctx.lineTo(-4, 30);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(8, 25);
                ctx.lineTo(12, 35);
                ctx.lineTo(4, 30);
                ctx.closePath();
                ctx.fill();
                
                // 引擎核心
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(-6, 27, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(6, 27, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
            
            // 绘制子弹
            function drawBullets() {
                player.bullets.forEach((bullet, index) => {
                    // 移动子弹
                    bullet.y -= bullet.speed;
                    
                    // 移除超出画布的子弹
                    if (bullet.y < 0) {
                        player.bullets.splice(index, 1);
                        return;
                    }
                    
                    // 绘制子弹
                    ctx.fillStyle = bullet.color;
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // 绘制敌机
            function drawEnemies() {
                enemies.forEach((enemy, index) => {
                    // 移动敌机
                    enemy.y += enemy.speed;
                    
                    // 移除超出画布的敌机
                    if (enemy.y > canvas.height) {
                        enemies.splice(index, 1);
                        return;
                    }
                    
                    // 绘制敌机
                    ctx.fillStyle = enemy.color;
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y);
                    ctx.lineTo(enemy.x - enemy.size, enemy.y + enemy.size * 2);
                    ctx.lineTo(enemy.x + enemy.size, enemy.y + enemy.size * 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 绘制敌机驾驶舱
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y + enemy.size / 2, enemy.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // 绘制星星背景
            function drawStars() {
                ctx.fillStyle = '#ffffff';
                stars.forEach(star => {
                    star.y += star.speed / 2;
                    if (star.y > canvas.height) {
                        star.y = 0;
                        star.x = Math.random() * canvas.width;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // 创建爆炸特效
            function createExplosion(x, y, size = 1) {
                const particleCount = 15 * size;
                for (let i = 0; i < particleCount; i++) {
                    explosions.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1.0,
                        decay: 0.02,
                        size: Math.random() * 4 + 2,
                        color: `hsl(${Math.random() * 60 + 15}, 100%, 50%)` // 橙红色系
                    });
                }
            }
            
            // 绘制爆炸特效
            function drawExplosions() {
                explosions.forEach((explosion, index) => {
                    explosion.x += explosion.vx;
                    explosion.y += explosion.vy;
                    explosion.life -= explosion.decay;
                    explosion.vx *= 0.98; // 阻力
                    explosion.vy *= 0.98;
                    
                    if (explosion.life <= 0) {
                        explosions.splice(index, 1);
                        return;
                    }
                    
                    ctx.save();
                    ctx.globalAlpha = explosion.life;
                    ctx.fillStyle = explosion.color;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.size * explosion.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
            
            // 绘制道具
            function drawPowerups() {
                powerups.forEach((powerup, index) => {
                    // 移动道具
                    powerup.y += powerup.speed;
                    powerup.rotation += 0.1;
                    
                    // 移除超出画布的道具
                    if (powerup.y > canvas.height) {
                        powerups.splice(index, 1);
                        return;
                    }
                    
                    // 绘制道具
                    ctx.save();
                    ctx.translate(powerup.x + powerup.size / 2, powerup.y + powerup.size / 2);
                    ctx.rotate(powerup.rotation);
                    
                    // 道具背景
                    ctx.fillStyle = powerup.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, powerup.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 道具边框
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 道具符号
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(powerup.symbol, 0, 0);
                    
                    ctx.restore();
                });
            }
            
            // 绘制辅机
            function drawWingman() {
                if (!playerPowerups.wingman) return;
                
                const wingmanX = player.x + player.width / 2;
                const wingmanY = player.y - 30;
                
                // 辅机主体
                ctx.fillStyle = '#45b7d1';
                ctx.beginPath();
                ctx.moveTo(wingmanX, wingmanY - 15);
                ctx.lineTo(wingmanX - 10, wingmanY + 10);
                ctx.lineTo(wingmanX + 10, wingmanY + 10);
                ctx.closePath();
                ctx.fill();
                
                // 辅机引擎
                ctx.fillStyle = '#ff4400';
                ctx.beginPath();
                ctx.moveTo(wingmanX - 8, wingmanY + 10);
                ctx.lineTo(wingmanX - 5, wingmanY + 20);
                ctx.lineTo(wingmanX - 2, wingmanY + 15);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(wingmanX + 8, wingmanY + 10);
                ctx.lineTo(wingmanX + 5, wingmanY + 20);
                ctx.lineTo(wingmanX + 2, wingmanY + 15);
                ctx.closePath();
                ctx.fill();
            }
            
            // 绘制Boss
            function drawBoss() {
                if (!boss) return;
                
                // Boss主体
                ctx.fillStyle = '#ff073a';
                ctx.beginPath();
                ctx.moveTo(boss.x + boss.width / 2, boss.y);
                ctx.lineTo(boss.x, boss.y + boss.height);
                ctx.lineTo(boss.x + boss.width, boss.y + boss.height);
                ctx.closePath();
                ctx.fill();
                
                // Boss护盾
                if (boss.shield > 0) {
                    ctx.strokeStyle = '#00b7ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Boss核心
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Boss炮台
                ctx.fillStyle = '#ff4400';
                ctx.fillRect(boss.x + 10, boss.y + 20, 15, 10);
                ctx.fillRect(boss.x + boss.width - 25, boss.y + 20, 15, 10);
                
                // Boss引擎
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.moveTo(boss.x + boss.width / 2 - 10, boss.y + boss.height);
                ctx.lineTo(boss.x + boss.width / 2, boss.y + boss.height + 20);
                ctx.lineTo(boss.x + boss.width / 2 + 10, boss.y + boss.height);
                ctx.closePath();
                ctx.fill();
            }
            
            // 绘制Boss攻击
            function drawBossAttacks() {
                if (!boss) return;
                
                // 绘制Boss子弹
                boss.bullets.forEach((bullet, index) => {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    
                    // 边界检查 - 扩大边界范围
                    if (bullet.x < -50 || bullet.x > canvas.width + 50 || 
                        bullet.y < -50 || bullet.y > canvas.height + 50) {
                        boss.bullets.splice(index, 1);
                        return;
                    }
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // 限制Boss子弹数量，防止内存泄漏
                if (boss.bullets.length > 50) {
                    boss.bullets = boss.bullets.slice(-30); // 只保留最新的30个
                }
                
                // 绘制Boss导弹
                boss.missiles.forEach((missile, index) => {
                    // 更新生命周期
                    if (missile.life) {
                        missile.life -= 16; // 假设60FPS
                        if (missile.life <= 0) {
                            boss.missiles.splice(index, 1);
                            return;
                        }
                    }
                    
                    // 更新目标位置（实时追踪玩家）
                    missile.targetX = player.x + player.width / 2;
                    missile.targetY = player.y + player.height / 2;
                    
                    const dx = missile.targetX - missile.x;
                    const dy = missile.targetY - missile.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        // 归一化方向向量并应用速度
                        const vx = (dx / distance) * missile.speed;
                        const vy = (dy / distance) * missile.speed;
                        missile.x += vx;
                        missile.y += vy;
                    }
                    
                    // 边界检查
                    if (missile.x < -10 || missile.x > canvas.width + 10 || 
                        missile.y < -10 || missile.y > canvas.height + 10) {
                        boss.missiles.splice(index, 1);
                        return;
                    }
                    
                    // 绘制导弹
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.arc(missile.x, missile.y, missile.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 绘制导弹尾迹
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(missile.x, missile.y);
                    ctx.lineTo(missile.x - dx * 0.1, missile.y - dy * 0.1);
                    ctx.stroke();
                });
                
                // 绘制Boss激光
                boss.lasers.forEach((laser, index) => {
                    // 更新生命周期
                    if (laser.life) {
                        laser.life -= 16; // 假设60FPS
                        if (laser.life <= 0) {
                            boss.lasers.splice(index, 1);
                            return;
                        }
                    }
                    
                    if (laser.tracking) {
                        laser.x = player.x + player.width / 2 - laser.width / 2;
                    }
                    
                    // 根据剩余生命值调整透明度
                    const alpha = laser.life ? laser.life / 1000 : 1;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                    ctx.restore();
                });
                
                // 限制Boss导弹和激光数量
                if (boss.missiles.length > 20) {
                    boss.missiles = boss.missiles.slice(-15);
                }
                if (boss.lasers.length > 15) {
                    boss.lasers = boss.lasers.slice(-10);
                }
            }
            
            // 生成敌机
            function spawnEnemy() {
                const size = Math.random() * 15 + 10;
                const enemyType = Math.floor(Math.random() * 3);
                
                let color, points, speed;
                
                switch (enemyType) {
                    case 0: // 红色敌机 - 慢速，低分
                        color = '#ff3860';
                        points = 10;
                        speed = Math.random() * 1.5 + 1;
                        break;
                    case 1: // 绿色敌机 - 中速，中分
                        color = '#23d160';
                        points = 20;
                        speed = Math.random() * 2 + 1.5;
                        break;
                    case 2: // 蓝色敌机 - 快速，高分
                        color = '#3273dc';
                        points = 50;
                        speed = Math.random() * 2.5 + 2;
                        break;
                }
                
                enemies.push({
                    x: Math.random() * (canvas.width - size * 2) + size,
                    y: -size * 2,
                    size: size,
                    speed: speed,
                    color: color,
                    points: points
                });
            }
            
            // 生成道具
            function spawnPowerup() {
                const powerupTypes = ['fireRate', 'multiBullet', 'wingman', 'health'];
                const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                
                let color, symbol;
                switch (type) {
                    case 'fireRate':
                        color = '#ff6b35';
                        symbol = '⚡';
                        break;
                    case 'multiBullet':
                        color = '#4ecdc4';
                        symbol = '💥';
                        break;
                    case 'wingman':
                        color = '#45b7d1';
                        symbol = '🛸';
                        break;
                    case 'health':
                        color = '#e74c3c';
                        symbol = '❤️';
                        break;
                }
                
                powerups.push({
                    x: Math.random() * (canvas.width - 30) + 15,
                    y: -30,
                    size: 20,
                    speed: 2,
                    color: color,
                    symbol: symbol,
                    type: type,
                    rotation: 0
                });
            }
            
            // 生成Boss
            function spawnBoss() {
                if (bossActive) return;
                
                boss = {
                    x: canvas.width / 2 - 50,
                    y: 50,
                    width: 100,
                    height: 80,
                    maxHealth: 1000,
                    health: 1000,
                    shield: 200,
                    maxShield: 200,
                    phase: 1,
                    speed: 1,
                    direction: 1,
                    lastAttack: 0,
                    attackDelay: 3000, // 增加攻击间隔
                    bullets: [],
                    missiles: [],
                    lasers: [],
                    invulnerable: false,
                    invulnerableTime: 0,
                    phaseChangeTime: 0
                };
                
                bossActive = true;
                sounds.bossSpawn();
            }
            
            // 射击函数
            function shoot() {
                const currentTime = Date.now();
                const adjustedDelay = player.shootDelay / playerPowerups.fireRate;
                
                if (currentTime - player.lastShot > adjustedDelay) {
                    const centerX = player.x + player.width / 2;
                    const bulletCount = playerPowerups.multiBullet;
                    
                    if (bulletCount === 1) {
                        // 单发子弹
                        player.bullets.push({
                            x: centerX,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                    } else if (bulletCount === 2) {
                        // 双发子弹
                        player.bullets.push({
                            x: centerX - 8,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                        player.bullets.push({
                            x: centerX + 8,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                    } else if (bulletCount === 3) {
                        // 三发子弹
                        player.bullets.push({
                            x: centerX,
                            y: player.y,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                        player.bullets.push({
                            x: centerX - 12,
                            y: player.y + 5,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                        player.bullets.push({
                            x: centerX + 12,
                            y: player.y + 5,
                            radius: 3,
                            speed: 10,
                            color: '#00ffaa'
                        });
                    }
                    
                    player.lastShot = currentTime;
                    sounds.shoot(); // 播放射击音效
                }
            }
            
            // 碰撞检测
            function checkCollisions() {
                // 子弹与敌机碰撞
                player.bullets.forEach((bullet, bulletIndex) => {
                    enemies.forEach((enemy, enemyIndex) => {
                        const dx = bullet.x - enemy.x;
                        const dy = bullet.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < enemy.size + bullet.radius) {
                            // 创建爆炸特效
                            createExplosion(enemy.x, enemy.y, enemy.size / 10);
                            
                            // 播放爆炸音效
                            sounds.explosion();
                            
                            // 移除子弹和敌机
                            player.bullets.splice(bulletIndex, 1);
                            enemies.splice(enemyIndex, 1);
                            
                            // 增加分数
                            score += enemy.points;
                            scoreElement.textContent = score;
                            
                            // 每1000分升一级
                            if (score % 1000 < enemy.points && score >= 1000) {
                                level++;
                                levelElement.textContent = level;
                                sounds.levelUp(); // 播放升级音效
                            }
                        }
                    });
                });
                
                // 玩家与道具碰撞
                powerups.forEach((powerup, index) => {
                    const dx = (player.x + player.width / 2) - (powerup.x + powerup.size / 2);
                    const dy = (player.y + player.height / 2) - (powerup.y + powerup.size / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.width / 2 + powerup.size) {
                        // 收集道具
                        collectPowerup(powerup.type);
                        powerups.splice(index, 1);
                        sounds.powerup();
                    }
                });
                
                // 玩家与敌机碰撞 - 增加无敌时间机制
                if (!player.invulnerable) {
                    enemies.forEach((enemy, index) => {
                        const dx = (player.x + player.width / 2) - enemy.x;
                        const dy = (player.y + player.height / 2) - (enemy.y + enemy.size);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < player.width / 2 + enemy.size) {
                            // 创建爆炸特效
                            createExplosion(enemy.x, enemy.y, enemy.size / 10);
                            
                            // 播放击中音效
                            sounds.hit();
                            
                            // 移除敌机
                            enemies.splice(index, 1);
                            
                            // 检查是否有辅机保护
                            if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                // 辅机承受伤害
                                playerPowerups.wingmanHealth--;
                                if (playerPowerups.wingmanHealth <= 0) {
                                    playerPowerups.wingman = false;
                                }
                            } else {
                                // 减少生命值
                                lives--;
                                livesElement.textContent = lives;
                                
                                // 启动无敌时间
                                player.invulnerable = true;
                                player.invulnerableTime = Date.now();
                                player.flashTime = 0;
                                
                                // 检查游戏结束
                                if (lives <= 0) {
                                    gameOver = true;
                                    finalScoreElement.textContent = score;
                                    gameOverElement.style.display = 'block';
                                    sounds.gameOver(); // 播放游戏结束音效
                                    stopBGM(); // 停止背景音乐
                                    cancelAnimationFrame(animationId);
                                }
                            }
                        }
                    });
                }
                
                // Boss相关碰撞检测
                if (bossActive && boss) {
                    // 玩家子弹与Boss碰撞
                    player.bullets.forEach((bullet, bulletIndex) => {
                        // 再次检查Boss是否存在（防止在循环中Boss被销毁）
                        if (!boss) return;
                        
                        const dx = bullet.x - (boss.x + boss.width / 2);
                        const dy = bullet.y - (boss.y + boss.height / 2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < boss.width / 2 + bullet.radius) {
                            // 移除子弹
                            player.bullets.splice(bulletIndex, 1);
                            
                            if (boss.shield > 0) {
                                // 攻击护盾
                                boss.shield -= 10;
                                if (boss.shield <= 0) {
                                    sounds.bossShieldBreak();
                                }
                            } else {
                                // 攻击Boss本体
                                boss.health -= 20;
                                createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, 2);
                                
                                if (boss.health <= 0) {
                                    // Boss死亡
                                    createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, 5);
                                    score += 1000; // Boss奖励分数
                                    scoreElement.textContent = score;
                                    bossActive = false;
                                    boss = null;
                                    sounds.explosion();
                                    return; // 立即返回，避免继续处理
                                }
                            }
                        }
                    });
                    
                    // 玩家与Boss攻击碰撞
                    if (!player.invulnerable && boss) {
                        // Boss子弹碰撞
                        boss.bullets.forEach((bullet, index) => {
                            // 再次检查Boss是否存在
                            if (!boss) return;
                            
                            const dx = (player.x + player.width / 2) - bullet.x;
                            const dy = (player.y + player.height / 2) - bullet.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < player.width / 2 + bullet.radius) {
                                boss.bullets.splice(index, 1);
                                createExplosion(bullet.x, bullet.y, 1);
                                sounds.hit();
                                
                                // 处理伤害
                                if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                    playerPowerups.wingmanHealth--;
                                    if (playerPowerups.wingmanHealth <= 0) {
                                        playerPowerups.wingman = false;
                                    }
                                } else {
                                    lives--;
                                    livesElement.textContent = lives;
                                    player.invulnerable = true;
                                    player.invulnerableTime = Date.now();
                                    player.flashTime = 0;
                                    
                                    if (lives <= 0) {
                                        gameOver = true;
                                        finalScoreElement.textContent = score;
                                        gameOverElement.style.display = 'block';
                                        sounds.gameOver();
                                        stopBGM();
                                        cancelAnimationFrame(animationId);
                                    }
                                }
                            }
                        });
                        
                        // Boss导弹碰撞
                        if (boss && boss.missiles) {
                            boss.missiles.forEach((missile, index) => {
                                // 再次检查Boss是否存在
                                if (!boss) return;
                                
                                const dx = (player.x + player.width / 2) - missile.x;
                                const dy = (player.y + player.height / 2) - missile.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < player.width / 2 + missile.radius) {
                                    boss.missiles.splice(index, 1);
                                    createExplosion(missile.x, missile.y, 2);
                                    sounds.explosion();
                                    
                                    // 处理伤害
                                    if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                        playerPowerups.wingmanHealth--;
                                        if (playerPowerups.wingmanHealth <= 0) {
                                            playerPowerups.wingman = false;
                                        }
                                    } else {
                                        lives--;
                                        livesElement.textContent = lives;
                                        player.invulnerable = true;
                                        player.invulnerableTime = Date.now();
                                        player.flashTime = 0;
                                        
                                        if (lives <= 0) {
                                            gameOver = true;
                                            finalScoreElement.textContent = score;
                                            gameOverElement.style.display = 'block';
                                            sounds.gameOver();
                                            stopBGM();
                                            cancelAnimationFrame(animationId);
                                        }
                                    }
                                }
                            });
                        }
                        
                        // Boss激光碰撞
                        if (boss && boss.lasers) {
                            boss.lasers.forEach((laser, index) => {
                                // 再次检查Boss是否存在
                                if (!boss) return;
                                
                                if (player.x < laser.x + laser.width && 
                                    player.x + player.width > laser.x && 
                                    player.y < laser.y + laser.height && 
                                    player.y + player.height > laser.y) {
                                    
                                    // 处理伤害
                                    if (playerPowerups.wingman && playerPowerups.wingmanHealth > 0) {
                                        playerPowerups.wingmanHealth--;
                                        if (playerPowerups.wingmanHealth <= 0) {
                                            playerPowerups.wingman = false;
                                        }
                                    } else {
                                        lives--;
                                        livesElement.textContent = lives;
                                        player.invulnerable = true;
                                        player.invulnerableTime = Date.now();
                                        player.flashTime = 0;
                                        
                                        if (lives <= 0) {
                                            gameOver = true;
                                            finalScoreElement.textContent = score;
                                            gameOverElement.style.display = 'block';
                                            sounds.gameOver();
                                            stopBGM();
                                            cancelAnimationFrame(animationId);
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            // 收集道具
            function collectPowerup(type) {
                switch (type) {
                    case 'fireRate':
                        playerPowerups.fireRate = Math.min(playerPowerups.fireRate + 0.5, 3);
                        break;
                    case 'multiBullet':
                        playerPowerups.multiBullet = Math.min(playerPowerups.multiBullet + 1, 3);
                        break;
                    case 'wingman':
                        playerPowerups.wingman = true;
                        playerPowerups.wingmanHealth = 3; // 辅机有3点生命值
                        break;
                    case 'health':
                        lives = Math.min(lives + 1, 5); // 最多5条生命
                        livesElement.textContent = lives;
                        break;
                }
            }
            
            // Boss攻击函数
            function bossAttack() {
                if (!boss || boss.invulnerable) return;
                
                const currentTime = Date.now();
                if (currentTime - boss.lastAttack < boss.attackDelay) return;
                
                boss.lastAttack = currentTime;
                
                switch (boss.phase) {
                    case 1:
                        // 阶段1：基础攻击
                        bossBasicAttack();
                        break;
                    case 2:
                        // 阶段2：强化攻击
                        bossEnhancedAttack();
                        break;
                    case 3:
                        // 阶段3：狂暴攻击
                        bossBerserkAttack();
                        break;
                }
            }
            
            // Boss基础攻击
            function bossBasicAttack() {
                // 激光扫射
                boss.lasers.push({
                    x: boss.x,
                    y: boss.y + boss.height,
                    width: 4,
                    height: canvas.height,
                    speed: 0,
                    damage: 1,
                    life: 1000 // 1秒后消失
                });
                
                boss.lasers.push({
                    x: boss.x + boss.width - 4,
                    y: boss.y + boss.height,
                    width: 4,
                    height: canvas.height,
                    speed: 0,
                    damage: 1,
                    life: 1000 // 1秒后消失
                });
                
                // 导弹齐射
                for (let i = 0; i < 3; i++) {
                    boss.missiles.push({
                        x: boss.x + boss.width / 2 + (i - 1) * 20, // 分散发射位置
                        y: boss.y + boss.height,
                        radius: 4,
                        speed: 2.5, // 稍微降低速度让追踪更明显
                        targetX: player.x + player.width / 2,
                        targetY: player.y + player.height / 2,
                        damage: 2,
                        life: 3000 // 3秒后自动消失
                    });
                }
                
                // 召唤小兵
                for (let i = 0; i < 2; i++) {
                    enemies.push({
                        x: boss.x + (i * 40),
                        y: boss.y + boss.height,
                        size: 15,
                        speed: 2,
                        color: '#ff3860',
                        points: 10
                    });
                }
            }
            
            // Boss强化攻击
            function bossEnhancedAttack() {
                // 环形弹幕
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    boss.bullets.push({
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        radius: 3,
                        speed: 2,
                        vx: Math.cos(angle) * 2,
                        vy: Math.sin(angle) * 2,
                        damage: 1
                    });
                }
                
                // 激光网
                for (let i = 0; i < 5; i++) {
                    boss.lasers.push({
                        x: (i * canvas.width / 4),
                        y: boss.y + boss.height,
                        width: 2,
                        height: canvas.height,
                        speed: 0,
                        damage: 1,
                        life: 1500 // 1.5秒后消失
                    });
                }
                
                // 冲锋攻击
                boss.speed = 3;
                boss.direction = player.x < boss.x ? -1 : 1;
            }
            
            // Boss狂暴攻击
            function bossBerserkAttack() {
                // 全屏弹幕 - 减少子弹数量
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    boss.bullets.push({
                        x: boss.x + boss.width / 2,
                        y: boss.y + boss.height / 2,
                        radius: 4,
                        speed: 3,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        damage: 2
                    });
                }
                
                // 追踪激光
                boss.lasers.push({
                    x: boss.x + boss.width / 2,
                    y: boss.y + boss.height,
                    width: 6,
                    height: canvas.height,
                    speed: 0,
                    damage: 2,
                    tracking: true,
                    life: 800 // 0.8秒后消失
                });
                
                // 自爆小兵
                for (let i = 0; i < 3; i++) {
                    enemies.push({
                        x: boss.x + (i * 30),
                        y: boss.y + boss.height,
                        size: 12,
                        speed: 4,
                        color: '#ff0000',
                        points: 20,
                        explosive: true
                    });
                }
            }
            
            // 更新游戏状态
            function update() {
                // 处理无敌时间
                if (player.invulnerable) {
                    if (Date.now() - player.invulnerableTime > player.invulnerableDuration) {
                        player.invulnerable = false;
                        player.flashTime = 0;
                    }
                }
                
                // 平滑移动玩家
                let targetVelocity = 0;
                
                if (keys.ArrowLeft) {
                    targetVelocity = -player.maxSpeed;
                } else if (keys.ArrowRight) {
                    targetVelocity = player.maxSpeed;
                }
                
                // 应用加速度和减速度
                if (targetVelocity !== 0) {
                    // 加速
                    if (Math.abs(player.velocity) < Math.abs(targetVelocity)) {
                        player.velocity += targetVelocity > 0 ? player.acceleration : -player.acceleration;
                    } else {
                        player.velocity = targetVelocity;
                    }
                } else {
                    // 减速
                    if (player.velocity > 0) {
                        player.velocity = Math.max(0, player.velocity - player.deceleration);
                    } else if (player.velocity < 0) {
                        player.velocity = Math.min(0, player.velocity + player.deceleration);
                    }
                }
                
                // 应用移动
                player.x += player.velocity;
                
                // 边界检查
                if (player.x < 0) {
                    player.x = 0;
                    player.velocity = 0;
                } else if (player.x > canvas.width - player.width) {
                    player.x = canvas.width - player.width;
                    player.velocity = 0;
                }
                
                // 射击
                if (keys[' ']) {
                    shoot();
                }
                
                // 随机生成敌机
                if (Math.random() < 0.03) {
                    spawnEnemy();
                }
                
                // 随机生成道具
                if (Math.random() < 0.005) { // 道具生成概率较低
                    spawnPowerup();
                }
                
                // Boss逻辑
                if (bossActive && boss) {
                    // Boss移动
                    boss.x += boss.speed * boss.direction;
                    if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
                        boss.direction *= -1;
                    }
                    
                    // Boss攻击
                    bossAttack();
                    
                    // Boss阶段转换
                    if (boss.health <= 700 && boss.phase === 1) {
                        boss.phase = 2;
                        boss.attackDelay = 2000; // 增加攻击间隔
                        boss.invulnerable = true;
                        boss.phaseChangeTime = Date.now();
                        sounds.bossPhaseChange();
                    } else if (boss.health <= 300 && boss.phase === 2) {
                        boss.phase = 3;
                        boss.attackDelay = 1500; // 增加攻击间隔
                        boss.invulnerable = true;
                        boss.phaseChangeTime = Date.now();
                        sounds.bossPhaseChange();
                    }
                    
                    // 阶段转换无敌时间
                    if (boss.invulnerable && Date.now() - boss.phaseChangeTime > 2000) {
                        boss.invulnerable = false;
                    }
                } else if (!bossActive && score - lastBossScore >= bossSpawnScore) {
                    // 生成Boss
                    spawnBoss();
                    lastBossScore = score;
                }
                
                // 检查碰撞
                checkCollisions();
            }
            
            // 绘制游戏
            function draw() {
                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制背景和游戏元素
                drawStars();
                drawPlayer();
                drawWingman(); // 绘制辅机
                drawBullets();
                drawEnemies();
                drawPowerups(); // 绘制道具
                drawBoss(); // 绘制Boss
                drawBossAttacks(); // 绘制Boss攻击
                drawExplosions();
            }
            
            // 游戏循环
            function gameLoop() {
                if (!gameOver) {
                    update();
                    draw();
                    animationId = requestAnimationFrame(gameLoop);
                }
            }
            
            // 初始化游戏
            function initGame() {
                score = 0;
                lives = 3;
                level = 1;
                gameOver = false;
                
                scoreElement.textContent = score;
                livesElement.textContent = lives;
                levelElement.textContent = level;
                
                player.x = canvas.width / 2 - 25;
                player.y = canvas.height - 70;
                player.bullets = [];
                player.velocity = 0; // 重置速度
                player.invulnerable = false;
                player.invulnerableTime = 0;
                player.flashTime = 0;
                
                enemies = [];
                explosions = [];
                powerups = [];
                playerPowerups = {
                    fireRate: 1,
                    multiBullet: 1,
                    wingman: false,
                    wingmanHealth: 0
                };
                boss = null;
                bossActive = false;
                lastBossScore = 0;
                
                gameOverElement.style.display = 'none';
                
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                // 自动启动BGM
                setTimeout(() => {
                    if (bgmEnabled) {
                        startBGM();
                    }
                }, 1000);
                
                gameLoop();
            }
            
            // 音效开关
            const audioToggle = document.getElementById('audioToggle');
            audioToggle.addEventListener('click', () => {
                audioEnabled = !audioEnabled;
                audioToggle.textContent = audioEnabled ? '🔊 音效开启' : '🔇 音效关闭';
                audioToggle.style.background = audioEnabled ? 
                    'linear-gradient(135deg, #3498db, #2980b9)' : 
                    'linear-gradient(135deg, #95a5a6, #7f8c8d)';
            });
            
            // BGM开关
            const bgmToggle = document.getElementById('bgmToggle');
            bgmToggle.addEventListener('click', () => {
                bgmEnabled = !bgmEnabled;
                bgmToggle.textContent = bgmEnabled ? '🎵 BGM开启' : '🔇 BGM关闭';
                bgmToggle.style.background = bgmEnabled ? 
                    'linear-gradient(135deg, #e74c3c, #c0392b)' : 
                    'linear-gradient(135deg, #95a5a6, #7f8c8d)';
                
                if (bgmEnabled) {
                    startBGM();
                } else {
                    stopBGM();
                }
            });
            
            // 重新开始游戏
            restartBtn.addEventListener('click', initGame);
            
            // 开始游戏
            initGame();
            
            
        });
    </script>
</body>

</html>
